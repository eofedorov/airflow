{
  "doc_key": "adr-2025-03-redis-carts",
  "title": "ADR-2025-03: Redis как основной кеш для корзин (read-through + write-through)",
  "doc_type": "adr",
  "created_at": "2025-03-11",
  "content": "# Статус\nПринято (2025-03-11)\n\n# Контекст\ncart-service — высоконагруженный сервис. На пиках чтение корзины становится одним из топ источников нагрузки на Postgres, что ухудшает чекаут. In-process кеш на подах пробовали, но:\n- прогрев разный на каждом поде\n- деплой сбрасывает кеш и вызывает шторм\n- память растет непредсказуемо\n\nRedis уже используется для сессий, rate-limit и идемпотентности платежей, поэтому логично применить его как общий кеш.\n\n# Решение\nИспользовать Redis как основной кеш для payload корзины, при этом Postgres остается источником истины.\n- read-through на GET\n- write-through на мутациях\n- TTL + джиттер\n- policy: allkeys-lfu\n\nЭто НЕ означает, что Redis становится системой записи.\n\n# Дизайн\n## Формат ключей\nКлюч должен быть стабильным:\n- cart:<user_id>:v<version>\n\n## TTL\n- CART_CACHE_TTL_SECONDS=900\n- CART_CACHE_TTL_JITTER_SECONDS=120\n\n## Сериализация\n- msgpack v2 (быстрее и меньше чем JSON)\n- payload включает cart_id, version, currency, items, минимальные totals\nИсключить:\n- расширенные рекомендации\n- профиль пользователя\n\n## Redis конфиг (prod baseline)\n`conf\nmaxmemory 18gb\nmaxmemory-policy allkeys-lfu\nactivedefrag yes\nlazyfree-lazy-eviction yes\n`\n\n## Поведение cart-service\nGET:\n- при hit возвращаем X-Cache: hit\n- при miss читаем из Postgres и пишем в Redis\n- при недоступном Redis: fallback на Postgres, X-Cache: bypass\n\nМутации:\n- транзакция в Postgres\n- инкремент version\n- запись нового payload в Redis\n- публикация cart.updated (для аналитики, не критично)\n\n## ETag и optimistic concurrency\ncart-service возвращает ETag, checkout-service передает If-Match.\nОжидание: 409 при несовпадении, клиент должен перезагрузить корзину.\n\nРиск: если ETag вычисляется из кешированного payload, eviction/rehydrate может повысить mismatch. Это позже подтвердилось в PM-2025-11.\n\n# Последствия\nПлюсы:\n- меньше Postgres read load\n- ниже latency\n\nМинусы:\n- Redis становится большим радиусом поражения: eviction шторм возвращает нагрузку в БД\n- риск раздувания payload\n- риск partial deploy при смене формата ключей\n\n# Альтернативы\n- Postgres-only с репликами: дороже и p95 хуже\n- Хранить корзины в Redis как источник истины: отклонено\n- Клиентский кеш: отклонено\n\n# Требования и follow-ups\n- добавить алерты на redis_evicted_keys_total и размер payload\n- добавить жесткий лимит CART_CACHE_MAX_BYTES и пропуск кеширования больших payload\n- ранбук на инциденты (RB-2026-02)\n\n# Примечание о противоречиях\nЭта ADR про производительность. Если Redis будет причиной повторяющихся инцидентов, возможен пересмотр: кешировать только минимальный набор (sku+qty) или вовсе уйти в Postgres+реплики. Это пока не принято, но обсуждалось после PM-2025-11.",
  "language": "ru"
}