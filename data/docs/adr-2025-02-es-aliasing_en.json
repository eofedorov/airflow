{
  "doc_key": "adr-2025-02-es-aliasing",
  "title": "ADR-2025-02: Elasticsearch Aliasing and Zero-Downtime Reindexing",
  "doc_type": "adr",
  "created_at": "2025-02-06",
  "content": "# ADR-2025-02: Elasticsearch Index Aliasing and Zero-Downtime Reindexing for Products\n\n## Status\nAccepted (2025-02-06)\n\n## Context\nProduct search uses Elasticsearch. We frequently need to evolve mappings (new analyzers, new fields, changed types). Elasticsearch does not allow many mapping changes in-place. Reindexing the full catalog (tens of millions of documents) takes hours, and doing it “live” risks downtime.\n\nPreviously, we used a single rolling index (e.g., `products-current`) and updated mappings whenever possible. This led to:\n- risky deploys when a mapping change was required\n- limited rollback options (mapping changes are hard to undo)\n- partial failures where search-api queries and mappings diverged\n\nWe want a predictable operational pattern that supports:\n- safe reindexing\n- atomic cutover\n- fast rollback\n- compatibility during deploy windows\n\n## Decision\nAdopt a read/write alias strategy:\n- Read alias: `products_read`\n- Write alias: `products_write`\n- Concrete indices: `products-v3-YYYY.MM.DD` (date is index creation date, not data date)\n\nindexing-worker writes to `products_write`. search-api reads from `products_read`. During reindex windows, these aliases may point to different concrete indices.\n\n## Technical design\n### Index template and mapping controls\nTemplate name: `products-template-v3`\nKey rules:\n- Dynamic mapping is restricted for attribute-like fields:\n  - `attributes.*` must be normalized to known types to avoid field explosion.\n- Set `index.mapping.total_fields.limit` to 1000 to prevent pathological documents.\n\nExample (partial) template settings:\n```json\n{\n  \"index_patterns\": [\"products-v3-*\"],\n  \"template\": {\n    \"settings\": {\n      \"number_of_shards\": 12,\n      \"number_of_replicas\": 1,\n      \"index.mapping.total_fields.limit\": 1000\n    }\n  }\n}\n```\n\n### Cutover process (standard)\n1. Create new index `products-v3-<today>` with updated template.\n2. Backfill:\n   - preferred: reindex from Postgres snapshot (catalog export)\n   - fallback: Elasticsearch `_reindex` from previous index\n3. Enable dual-write in indexing-worker for a fixed window:\n   - `INDEX_DUAL_WRITE=true`\n   - `INDEX_DUAL_WRITE_TARGET=products-v3-<today>`\n4. Switch `products_read` alias atomically to new index.\n5. After validation (query parity + doc counts), switch `products_write` to new index and disable dual-write.\n\nAlias switch example:\n```bash\ncurl -X POST localhost:9200/_aliases -H 'Content-Type: application/json' -d '{\n  \"actions\": [\n    {\"remove\": {\"alias\": \"products_read\", \"index\": \"products-v3-2025.01.30\"}},\n    {\"add\":    {\"alias\": \"products_read\", \"index\": \"products-v3-2025.02.06\"}}\n  ]\n}'\n```\n\n### Validation criteria\n- `/_cat/indices` shows doc count within 0.5% of expected catalog size.\n- Search parity checks:\n  - 20 canonical queries have comparable totals (+/- 5%)\n  - filters return non-empty facets for common brands\n- No sustained `query_shard_exception` in search-api logs.\n\n### Rollback\nRollback is repointing `products_read` back to prior index. This is the key reason for aliases.\n\n## Consequences\n### Positive\n- Zero-downtime mapping evolution\n- Fast rollback without needing to restore an old cluster state\n- Safer deploy windows: search-api can be upgraded independently\n\n### Negative / risks\n- Storage overhead: during dual-write, two indices exist simultaneously.\n- Operational complexity: alias switch and ILM/retention patterns must be maintained.\n- New failure mode: if `products_read` alias is missing or points to a deleted index, search-api errors hard (`index_not_found_exception`).\n\n## Alternatives considered\n1. **Single index with ILM only**: rejected; ILM manages lifecycle, not mapping evolution.\n2. **Use OpenSearch or a managed search service**: deferred; not in scope and would require broader migration.\n3. **Blue/green full cluster**: rejected due to cost and complexity.\n\n## Edge cases\n- Disk watermark: if data nodes cross watermark, shards become unassigned and alias switching won’t help (see ES runbook).\n- Mapping conflicts: if a field changes type (string -> number), documents will fail to index; dual-write must be monitored for `mapper_parsing_exception`.\n- Analyzer changes: query relevance may change; product team must sign off on relevance diffs.\n\n## Follow-ups\n- Ensure ILM policies reference `products-v3-*` patterns after each alias strategy change.\n- Add weekly checklist items for retention and ILM health.\n\n## Operational conventions\n- Index naming is **creation date**, not “data date”. Do not create indices named by ingestion date; it breaks retention checks.\n- ILM policy (current): `products-ilm-v3`\n  - hot phase: rollover at 50GB\n  - delete phase: 14 days\n- Retention is enforced by ILM, but during incidents oncall may delete indices manually; follow up must restore ILM correctness.",
  "language": "en"
}