{
  "doc_key": "adr-2024-12-stripe-webhooks",
  "title": "ADR-2024-12: Stripe webhooks как источник истины по платежам",
  "doc_type": "adr",
  "created_at": "2024-12-15",
  "content": "# Статус\nПринято (2024-12-15)\n\n# Контекст\nРаньше checkout-service делал активный поллинг Stripe (retrieve PaymentIntent) чтобы понять финальный статус. Это приводило к:\n- 429 Too Many Requests на пиках\n- гонкам: заказ pending при фактически успешном платеже\n- сложным retry/backoff в горячем пути и росту p95\n- слабой аудитируемости: поддержки нет каноничного журнала событий\n\nУ нас есть legacy Node сервис payment-gateway, который уже принимает Stripe webhooks, но его выход не считался авторитетным. По сути было два конкурирующих источника правды.\n\n# Решение\nСделать Stripe webhooks авторитетным источником переходов платежного статуса.\n- payment-gateway:\n  1) проверяет подпись\n  2) сохраняет сырое событие в Postgres\n  3) ставит в очередь внутреннюю обработку\n- checkout-service:\n  - не поллит Stripe в запросах пользователя\n  - обновляет payments и orders только по результатам обработанных webhook событий\n\nПоллинг допускается только как оффлайновая ре-консиляция (например ежедневная) и для ручного инструмента поддержки.\n\n# Дизайн\n## Версия Stripe API\nФиксируем версию на 2023-10-16 в payment-gateway и логируем ее как stripe_api_version.\n\n## Endpoint\n- POST /webhooks/stripe\n- Требование: тело запроса должно быть raw, без переформатирования JSON.\n- В payment-gateway для этого маршрута использовать express.raw.\n\n## Проверка подписи\n- env: STRIPE_WEBHOOK_SECRET\n- При неверной подписи отвечаем 400.\nТиповой лог: StripeSignatureVerificationError.\n\n## Persistence\nТаблица stripe_events хранит payload целиком (jsonb) для аудита и replay.\n\nСхема:\n`sql\ncreate table stripe_events (\n  event_id text primary key,\n  type text not null,\n  created_at timestamptz not null default now(),\n  payload jsonb not null,\n  processed_at timestamptz,\n  process_error text\n);\ncreate index stripe_events_type_created_at_idx on stripe_events (type, created_at desc);\n`\n\n## Процессинг\n- Воркер берет event_id, читает payload, применяет переходы в транзакции.\n- Идемпотентность: PK event_id и уникальность на связях с payments.\n\n## Порядок событий\nStripe не гарантирует порядок. Процессор обязан терпеть:\n- дубликаты\n- out-of-order, включая refund события до succeeded\n\nПравило: переходы по возможности монотонные, не откатывать платеж из SUCCEEDED в PENDING.\n\n## Поведение при сбоях\nЕсли payment-gateway не может записать событие в Postgres, должен вернуть 500, чтобы Stripe ретраил. Нельзя отдавать 2xx без записи.\n\n# Последствия\nПлюсы:\n- меньше Stripe API вызовов и меньше 429\n- единый журнал событий\n- ясное разделение ответственности\n\nМинусы/риски:\n- webhook ingestion становится критичным для финализации заказа\n- регрессия в raw-body обработке сразу приводит к зависшим pending\n- нужны алерты на очередь и подписи (см. RB-2026-01)\n\n# Альтернативы\n- оставить поллинг: отклонено\n- перенести вебхуки в checkout-service: отклонено из-за владения ключами\n- публиковать события в Kafka: отложено\n\n# Заметки\n- ingress лимит тела должен быть достаточным, иначе 413.\n- Redis используется как ускорение, но корректность держится на Postgres.\n- В PM-2025-08 выяснилось, что downstream consumers должны быть идемпотентны даже если ingestion идемпотентен.",
  "language": "ru"
}