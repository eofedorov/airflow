{
  "doc_key": "adr-2025-03-redis-carts",
  "title": "ADR-2025-03: Redis as Primary Cache for Carts",
  "doc_type": "adr",
  "created_at": "2025-03-11",
  "content": "# ADR-2025-03: Redis as Primary Cache for Carts (Read-Through + Write-Through)\n\n## Status\nAccepted (2025-03-11)\n\n## Context\ncart-service is a high-QPS service. During peak events (sales, campaigns), cart reads become one of the top 3 DB load drivers. Before this ADR, cart-service hit Postgres on most reads. Even with indexes, p95 latency drifted above 450ms under load, which then impacted checkout-service because it fetches cart snapshots during checkout.\n\nWe tried in-process caching inside the FastAPI pods, but it had problems:\n- cache warm-up varied by pod; horizontal scaling caused cold starts\n- deploys flush caches and create “cache storms”\n- per-pod memory growth was unpredictable and caused OOMKilled in staging\n\nRedis is already in our stack (sessions, rate limits, Stripe idempotency), and we can leverage it as a shared cache.\n\n## Decision\nUse Redis as the primary cache for cart payloads with Postgres as the source of truth.\n\n- cart-service will implement:\n  - read-through cache for GET cart\n  - write-through cache update on mutations\n  - TTL-based expiration with jitter\n- Redis will use an eviction policy optimized for “hot carts”:\n  - `maxmemory-policy allkeys-lfu`\n\nThe decision explicitly does **not** make Redis the system of record for carts.\n\n## Technical design\n### Key format\nKey format is stable and must not change without a compatibility plan:\n- `cart:{user_id}:v{version}`\n\nRationale:\n- user_id is enough to address cart in our product model\n- version supports optimistic concurrency and helps avoid lost updates\n\n### TTL\n- Base TTL: 900 seconds (`CART_CACHE_TTL_SECONDS=900`)\n- TTL jitter: 0–120 seconds (`CART_CACHE_TTL_JITTER_SECONDS=120`) to avoid synchronized expiry storms\n\n### Serialization format\n- msgpack v2 payload (smaller and faster than JSON)\n- cart payload includes:\n  - cart_id, version, currency\n  - items (sku, qty, unit_price_minor)\n  - minimal totals (subtotal, tax estimate)\n\nExplicitly excluded (for now):\n- full recommendation metadata\n- customer profile fields\n\n### Redis configuration\nBaseline config (prod):\n```conf\nmaxmemory 18gb\nmaxmemory-policy allkeys-lfu\nactivedefrag yes\nlazyfree-lazy-eviction yes\n```\n\n### cart-service behavior\nRead path (`GET /api/cart/{user_id}`):\n1. If `CART_CACHE_BYPASS=true`, go to Postgres.\n2. Otherwise:\n   - try Redis GET\n   - on hit: return, set `X-Cache: hit`\n   - on miss: load from Postgres, write to Redis, set `X-Cache: miss`\n\nWrite path (mutations):\n- Update Postgres in a transaction.\n- Increment cart `version`.\n- Write new payload to Redis.\n- Publish `cart.updated` event (used by downstream analytics, not required for correctness).\n\n### ETags / concurrency contract\ncheckout-service uses `If-Match` with cart ETag for optimistic concurrency. cart-service returns:\n- `ETag: W/<etag>`\n- where `<etag>` is derived from `(version, item_hashes)`.\n\nNote: if ETag derivation depends on cached payload and Redis evicts keys, we might see increased mismatch rates. See “Consequences” and PM-2025-11.\n\n### Failure mode\nIf Redis is unavailable or error rate is high:\n- cart-service falls back to Postgres\n- it should not fail requests just because cache is down\n- it emits `redis_errors_total` and sets `X-Cache: bypass`\n\n## Consequences\n### Positive\n- Lower Postgres read load during peaks.\n- Improved latency and better checkout stability under normal conditions.\n\n### Negative / risks\n- Redis becomes a larger blast radius: eviction storms can push load back to Postgres suddenly.\n- Key/value size drift can cause memory pressure; we need monitoring for value size and eviction rate.\n- Partial deploy risk: changing serialization or key format can cause near-100% misses.\n\n## Alternatives considered\n1. **Postgres-only with more read replicas**: rejected; increases cost and still has higher p95 under spikes.\n2. **Store carts fully in Redis (source of truth)**: rejected; durability/consistency risk.\n3. **Client-side caching**: rejected; correctness issues and hard invalidation.\n\n## Follow-ups / requirements\n- Add alerting on `redis_evicted_keys_total` and `cart_cache_value_size_bytes`.\n- Add a hard cap on cart cache payload size (proposal: 128KB) and skip caching if exceeded.\n- Document incident response (see RB-2026-02 Redis evictions).\n- Add compatibility test ensuring key format remains stable.\n\n## Notes\nThis ADR optimizes for performance. If we observe repeated eviction-driven incidents, we may need to move toward a smaller cached representation or a different cache strategy (e.g., caching only item ids and prices, not computed totals).",
  "language": "en"
}