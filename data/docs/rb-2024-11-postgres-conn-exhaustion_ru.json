{
  "doc_key": "rb-2024-11-postgres-conn-exhaustion",
  "title": "Ранбук: исчерпание подключений Postgres (too many clients)",
  "doc_type": "runbook",
  "created_at": "2024-11-09",
  "content": "# Кратко\nРанбук для случаев, когда Postgres начинает отказывать в новых подключениях, или latency взлетает из-за очередей в пулах. Типовая ошибка: FATAL sorry, too many clients already.\n\nПричина чаще всего: сервисы обходят PgBouncer или увеличили pool/worker в деплое. Мы используем PgBouncer transaction pooling (ADR-2024-08).\n\n# Симптомы\n- Массовые 500 на checkout-service/cart-service/payment-gateway\n- Таймауты, зависания запросов\n\nЛоги FastAPI:\n- psycopg.OperationalError: FATAL sorry, too many clients already\n- sqlalchemy.exc.TimeoutError: QueuePool limit reached\n\nЛоги Node (pg):\n- remaining connection slots are reserved...\n\n# Архитектура\n- Primary Postgres (приложениям нельзя): postgres-primary.ecommerce-prod.svc:5432\n- PgBouncer (приложениям нужно): pgbouncer.ecommerce-prod.svc:6432\n- Миграции Alembic должны ходить в primary напрямую\n\n# Быстрый триаж\n1) Посчитать коннекты и топ-источники:\n`sql\nshow max_connections;\nselect count(*) as total from pg_stat_activity;\nselect application_name, usename, state, count(*)\nfrom pg_stat_activity\ngroup by 1,2,3\norder by count(*) desc\nlimit 15;\n`\nЕсли application_name пустой или дефолтный, это подозрение на неправильную строку подключения.\n\n2) Проверить idle in transaction:\n`sql\nselect pid, application_name, now() - xact_start as xact_age, query\nfrom pg_stat_activity\nwhere state = 'idle in transaction'\norder by xact_age desc\nlimit 20;\n`\n\n3) PgBouncer:\nЕсли доступен admin:\n`sql\nshow pools;\nshow stats;\n`\nСмотрите cl_waiting.\n\n# Митигирующие действия\n## A: Снизить параллелизм приложений (самое безопасное)\nДля FastAPI число воркеров умножает пул.\n- WEB_CONCURRENCY=2\n- DB_POOL_SIZE=10\n- DB_MAX_OVERFLOW=5\n\n`bash\nkubectl -n ecommerce-prod set env deploy/checkout-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\nkubectl -n ecommerce-prod set env deploy/cart-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\n`\nПодождать 2–3 минуты, проверить pg_stat_activity.\n\n## B: Вернуть сервисы на PgBouncer\nЕсли деплой поменял DATABASE_URL на primary:\n- Патчить env обратно на pgbouncer и перезапустить pods\n- Или откатить rollout\n\nЭто самый частый root cause резких всплесков.\n\n## C: Убить явно зависшие сессии (последний шанс)\nТолько если уверены, что это мусор (например тысячи idle in transaction от одного пода):\n`sql\nselect pg_terminate_backend(pid)\nfrom pg_stat_activity\nwhere application_name like 'checkout-service@%' and state='idle in transaction'\n  and now() - xact_start > interval '2 minutes';\n`\nРиск: упадут запросы, возможны частичные операции.\n\n## D: Включить rate limit для защиты БД\nЕсли система близка к коллапсу:\n- лимитировать /api/checkout/start и /api/cart/* на ingress\n- лучше 429 чем каскад 500\n- временно остановить indexing-worker\n\n# Восстановление\nНормально:\n- total connections < 70 процентов от max\n- PgBouncer cl_waiting близко к 0\n- p95 возвращается\n\n# Острые углы\n- Лики соединений: забыли закрывать session на исключениях\n- Неправильное использование sync и async engine (двойные пулы)\n- Prepared statements и session state ломаются в transaction pooling\n- Джобы (refund-reconciler, webhook workers) тоже потребляют коннекты, учитывайте их в анализе\n\n# Ссылки\n- ADR-2024-08 PgBouncer\n- RB-2025-06 rollout stuck (часто рядом)\n- PM-2025-07 про миграции через PgBouncer",
  "language": "ru"
}