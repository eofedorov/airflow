{
  "doc_key": "pm-2025-11-redis-evictions",
  "title": "Постмортем PM-2025-11: Redis eviction привел к ошибкам чекаута",
  "doc_type": "postmortem",
  "created_at": "2025-11-30",
  "content": "# Summary\n2025-11-29 Redis в ecommerce-prod вошел в режим устойчивого memory pressure, начались интенсивные eviction и скачки latency команд. Так как cart-service активно использует Redis (ADR-2025-03), а checkout-service опирается на ETag/If-Match для согласованности, eviction шторм вызвал всплеск 409 CART_VERSION_MISMATCH и 412 PRECONDITION_FAILED на /api/checkout/start.\n\nДанные корзины не потеряны (источник истины Postgres), но конверсия просела примерно на 47 минут.\n\n# Impact\n- 2025-11-29 09:12–09:59 UTC\n- 12.4 процента запросов /api/checkout/start вернули 409/412\n- p95 checkout вырос с 220мс до 780мс\n- p95 cart-service вырос с 120мс до 410мс\n\n# Detection\nСработали алерты RedisEvictionsHigh и CartVersionMismatchSpike.\nНа дашборде Redis было видно used_memory почти равен maxmemory (18GB), evicted_keys рос.\n\n# Timeline\n- 09:12 алерт на eviction\n- 09:16 рост 409/412 и жалобы продукта\n- 09:22 включили CART_CACHE_BYPASS=true и отключили writeback\n- 09:26 Postgres нагрузка выросла, но удержалась < 75 процентов CPU\n- 09:31 удалили часть oversized ключей (как крайняя мера)\n- 09:38 подготовили hotfix по payload\n- 09:45 постепенно включили кеш обратно\n- 09:59 метрики вернулись к норме\n\n# Root cause\nУтром релизнули фичу рекомендаций в корзине. Реализация сохранила расширенные рекомендации прямо в кешированный payload корзины. Средний размер значения cart:* вырос примерно в 6 раз (с ~30КБ до ~180КБ, p95 > 220КБ).\n\nRedis policy allkeys-lfu не смог спасти ситуацию при упоре в maxmemory: ключи выкидывались и сразу создавались заново. Дополнительно на части путей TTL выставлялся без джиттера, что синхронизировало истечения.\n\nВажно: ETag вычислялся из кешированного payload в одном из путей (особенно при rehydrate), поэтому churn усиливал mismatch.\n\n# Contributing factors\n- Не было лимита размера кешируемого payload\n- Нагрузочные тесты не включали shape рекомендаций\n- TTL jitter применялся не везде\n- checkout-service не делал retry на mismatch (считал 409 фатальным)\n\n# Resolution\n- Временно bypass Redis для чтения корзины\n- Частичная ручная чистка oversized ключей\n- Hotfix: хранить в кеше только sku рекомендаций, не весь объект\n- Постепенное возвращение кеша\n\n# Что было хорошо\n- Фича-флаг CART_CACHE_BYPASS уже существовал\n- PgBouncer защитил Postgres от коллапса при росте read load\n\n# Что было плохо\n- Оптимизация производительности превратилась в correctness-adjacent проблему\n- Не было мониторинга по размеру значений\n\n# Action items\n1) Ввести CART_CACHE_MAX_BYTES=131072 и пропуск кеширования при превышении\n2) Добавить метрику cart_cache_value_size_bytes (p50/p95) и алерт\n3) Протестировать TTL jitter единообразно, покрыть unit тестом\n4) Добавить в checkout-service одноразовый retry на CART_VERSION_MISMATCH\n5) Дополнить ADR-2025-03 запретом кешировать expanded metadata\n\n# Противоречие с ADR\nADR-2025-03 предполагала, что Redis влияет только на latency и Postgres является fallback. На практике eviction шторм поднял mismatch и ударил по чекауту. Это не означает, что Redis нельзя использовать, но означает, что нельзя кешировать тяжелые payload и нельзя строить ETag на нестабильном представлении.\n\n# Ссылки\n- ADR-2025-03\n- RB-2026-02",
  "language": "ru"
}