{
  "doc_key": "rb-2026-01-stripe-webhook-backlog",
  "title": "Runbook: Stripe Webhook Backlog and Payment Pending Orders",
  "doc_type": "runbook",
  "created_at": "2026-01-14",
  "content": "# Summary\nThis runbook is for incidents where Stripe webhooks stop being processed quickly enough, causing orders to remain in `PAYMENT_PENDING`, refunds to stall, or duplicate fulfillment attempts. Our authoritative payment state comes from webhooks (see ADR-2024-12). When webhooks fail, **do not** “fix” by polling Stripe in the hot path; that usually increases API errors and makes recovery harder.\n\n**Primary services:** payment-gateway (Node), checkout-service (FastAPI)  \n**Dependencies:** Stripe, Postgres, Redis, ingress (raw body handling)\n\n# Symptoms\n## User-facing\n- “Payment pending” for > 2 minutes after card confirmation\n- Customer support sees PaymentIntent succeeded in Stripe dashboard, but our order is still pending\n- Refund button says “Requested” and never moves to “Completed”\n\n## Metrics and alerts\nPrometheus metrics emitted by payment-gateway:\n- `stripe_webhook_requests_total{status}`\n- `stripe_webhook_queue_depth`\n- `stripe_webhook_process_seconds_bucket`\n- `stripe_signature_fail_total`\n\nAlerts (common):\n- `StripeWebhookQueueHigh`: `stripe_webhook_queue_depth > 2000 for 10m`\n- `StripeWebhookSignatureFailures`: `rate(stripe_signature_fail_total[5m]) > 1`\n\n# Known architecture (current)\n1. Stripe delivers webhook to `POST /webhooks/stripe` on payment-gateway.\n2. payment-gateway verifies signature (Stripe API version pinned to 2023-10-16).\n3. Raw event is persisted to Postgres `stripe_events` (primary key `event_id`).\n4. A background worker processes events and updates `payments`/`orders` state.\n5. checkout-service queries order/payment state from Postgres only (no Stripe polling).\n\nIdempotency:\n- Postgres unique constraint on `stripe_events.event_id`\n- Redis key: `stripe:evt:{event_id}` TTL 7 days (optimization, not correctness)\n\n# Quick triage (first 10 minutes)\n## 1) Check Stripe dashboard delivery status\nLook for the endpoint `.../webhooks/stripe`. Common patterns:\n- 400 `invalid_signature`\n- 413 payload too large (ingress/body size)\n- 429 (we are throttling)\n- 500 (we error before persisting)\n\nIf Stripe is showing retries with 5xx, treat as a backlog incident; Stripe will continue retrying for hours.\n\n## 2) Check payment-gateway logs\n```bash\nkubectl -n ecommerce-prod logs deploy/payment-gateway --since=15m | egrep 'StripeSignature|invalid_signature|raw body|413|payload|ETIMEDOUT|deadlock'\n```\nTypical messages:\n- `StripeSignatureVerificationError: No signatures found matching the expected signature for payload`\n- `request entity too large` (ingress)\n- `Error: connect ETIMEDOUT postgres` (DB)\n- `deadlock detected` (rare; DB)\n\n## 3) Validate raw body handling is intact\nWebhook verification requires the unmodified raw request body. If someone enabled `express.json()` globally before the webhook route, signature checks will fail.\nCode must look like:\n```js\napp.post('/webhooks/stripe',\n  express.raw({ type: 'application/json' }),\n  handleStripeWebhook\n)\n```\nIf not, rollback immediately.\n\n## 4) Check Postgres write health\nIf payment-gateway can’t persist `stripe_events`, we must return 500 so Stripe retries.\nRun:\n```sql\nselect count(*) from stripe_events where created_at > now() - interval '10 minutes';\nselect max(created_at) from stripe_events;\n```\nIf `max(created_at)` is stale, persistence is broken.\n\n# Mitigation playbook\nChoose based on observed error type.\n\n## Mitigation A: Signature failures (400)\n**Goal:** stop rejecting valid Stripe events.\n1. Confirm `STRIPE_WEBHOOK_SECRET` matches Stripe endpoint secret.\n```bash\nkubectl -n ecommerce-prod exec deploy/payment-gateway -- printenv | grep STRIPE_WEBHOOK_SECRET\n```\n2. Ensure ingress does not modify body:\n- NGINX ingress must have `proxy-request-buffering: \"on\"` and should not decompress/transform.\n- If a WAF started normalizing JSON, disable it for `/webhooks/stripe` path.\n3. Roll back payment-gateway to last known good tag (commonly `payment-gateway:1.38.2`).\n```bash\nkubectl -n ecommerce-prod rollout undo deploy/payment-gateway\n```\n\n## Mitigation B: Payload too large (413)\nThis can happen when events include expanded objects (e.g., invoice lines).\n1. Increase ingress body size for this path only.\nExample annotation in helm values:\n```yaml\nnginx.ingress.kubernetes.io/proxy-body-size: \"2m\"\n```\n2. Verify the path routing doesn’t go through a gateway with 1MB limit.\n\n## Mitigation C: We are slow / queue depth grows\nIf 2xx responses are happening but queue depth climbs, processing is slow.\n1. Increase worker concurrency cautiously:\n- `WEBHOOK_MAX_CONCURRENCY` from 20 -> 50\n```bash\nkubectl -n ecommerce-prod set env deploy/payment-gateway WEBHOOK_MAX_CONCURRENCY=50\n```\n2. Reduce DB contention:\n- Temporarily disable non-essential side effects (email receipts):\n  - `PAYMENTS_SEND_EMAILS=false`\n3. If DB is struggling, prefer “persist + defer processing”:\n- `WEBHOOK_DEFER_PROCESSING=true` (persist event, enqueue minimal job)\n4. If the queue is in Redis and Redis is failing, switch to in-memory queue (degraded):\n- `WEBHOOK_QUEUE_BACKEND=memory`\n**Caution:** memory queue is not durable; only use if Redis is the root cause and Stripe retries are working.\n\n## Mitigation D: Postgres timeouts / errors\nIf payment-gateway returns 500 due to DB timeouts, the backlog grows but Stripe will retry. The goal is to restore DB health first.\n1. Confirm this is not connection exhaustion (see RB-2024-11).\n2. Reduce webhook concurrency temporarily to reduce DB pressure:\n- `WEBHOOK_MAX_CONCURRENCY=10`\n3. If there are deadlocks, check recent schema changes and indexes on `stripe_events` and `payments`.\n\n# Safe replay / catch-up\nNormally, Stripe retries are enough. Manual replay is only needed if:\n- we returned 2xx without persisting (bug), or\n- we persisted but processing worker was down and Stripe stopped retrying (rare), or\n- support needs immediate correction for a VIP order.\n\nReplayer job:\n```bash\nkubectl -n ecommerce-prod create job --from=cronjob/stripe-webhook-replay stripe-webhook-replay-manual\n```\nRules:\n- Replayer must be idempotent (by `event_id`).\n- Replayer processes in created_at order but must tolerate out-of-order event types.\n\n# Verification\n- Stripe dashboard: recent attempts are 2xx.\n- `stripe_webhook_queue_depth` trends down.\n- Orders created in last 15 minutes should not accumulate in `PAYMENT_PENDING`.\n\nSQL spot checks:\n```sql\nselect payment_status, count(*)\nfrom payments\nwhere created_at > now() - interval '30 minutes'\ngroup by 1;\n\nselect type, count(*)\nfrom stripe_events\nwhere created_at > now() - interval '30 minutes'\ngroup by 1\norder by 2 desc;\n```\n\n# Edge cases\n- **Out-of-order delivery:** `charge.refunded` can arrive before `payment_intent.succeeded` during retries. Our processor must check current payment state and apply transitions safely.\n- **Duplicate events:** Stripe may deliver the same `evt_*` multiple times. Never delete the unique constraint to “fix” errors.\n- **Partial deploys:** if only some pods have updated webhook secret, you’ll see intermittent signature failures and a confusing mix of 2xx/400.\n- **Clock drift:** signature validation rejects if timestamp tolerance is exceeded. If only one node fails, check NTP; do not widen tolerance beyond 5 minutes without security review.\n\n# References\n- ADR-2024-12 Stripe webhooks as source of truth\n- Onboarding: Payments flow (OB-2025-04)\n- Postmortem: PM-2025-08 webhook retries and duplicate fulfillment",
  "language": "en"
}