{
  "doc_key": "kb-2024-11-runbook-postgres-connection-exhaustion",
  "title": "Runbook: Postgres Connection Exhaustion (too many clients) Across Services",
  "doc_type": "runbook",
  "created_at": "2024-11-29",
  "content": "# Summary\nPostgres connection exhaustion manifests as widespread 500s with`FATAL: sorry, too many clients already`. This often occurs after a deploy that increases worker concurrency or when a connection pool misconfiguration disables pooling.\n\n# Services\n- checkout-service (FastAPI + SQLAlchemy 2.0)\n- cart-service (FastAPI)\n- search-api (FastAPI; reads catalog DB for filters)\n- payment-gateway (Node; writes payments and refunds)\n\n# Symptoms\n- Elevated 5xx across multiple services\n- Postgres metrics:\n  - `pg_stat_activity`shows connections near`max_connections`(prod default 600)\n  - CPU may be normal but connections saturate\n- App logs:\n  -`psycopg.OperationalError: connection failed: FATAL: sorry, too many clients already`\n\n# Triage\n## 1) Confirm max connections and current usage\n```sql\nshow max_connections;\nselect count(*) from pg_stat_activity;\nselect usename, application_name, count(*) from pg_stat_activity group by 1,2 order by 3 desc;\n```\nExpected application_name conventions:\n- `checkout-service@<pod>`\n- `cart-service@<pod>`\n- `payment-gateway@<pod>`\n\n## 2) Identify runaway clients\nLook for:\n- many idle in transaction\n- long-running queries holding connections\n```sql\nselect pid, usename, application_name, state, now()-xact_start as xact_age, query\nfrom pg_stat_activity\nwhere state <> 'idle'\norder by xact_age desc\nlimit 20;\n```\n\n# Mitigation\n## A) Reduce app concurrency quickly\nFor FastAPI services, gunicorn/uvicorn workers can multiply pools.\n1. Lower workers:\n- `WEB_CONCURRENCY=2`(temporary)\n```bash\nkubectl -n ecommerce-prod set env deploy/checkout-service WEB_CONCURRENCY=2\n```\n2. Lower async DB pool size:\n-`DB_POOL_SIZE=10`(default 30)\n-`DB_MAX_OVERFLOW=5`(default 20)\n\n## B) Enable pgbouncer (if disabled)\nWe run pgbouncer in transaction pooling mode.\n- Service DNS:`pgbouncer.ecommerce-prod.svc:6432`\n- Env var: `DATABASE_URL=postgresql+psycopg://...@pgbouncer:6432/app`\nIf a deploy pointed services at primary directly, revert.\n\n## C) Kill idle-in-transaction sessions (last resort)\nOnly after identifying offenders.\n```sql\nselect pg_terminate_backend(pid)\nfrom pg_stat_activity\nwhere state='idle in transaction' and now()-xact_start > interval '2 minutes';\n```\n\n## D) Protect primary\nIf saturation continues, apply rate limits to checkout endpoints and return 429.\n\n# Recovery\n- Connections drop below 70% of max\n- Error rate returns to baseline\n- Verify pgbouncer stats:\n```sql\nshow pools;\nshow stats;\n```\n\n# Edge cases\n- **Connection leaks**: if SQLAlchemy sessions are not closed on exception paths. Look for code changes around `async with session.begin()`.\n- **Background workers**: indexing-worker or refund-reconciler might have higher concurrency than web pods.\n- **Node service pooling**: payment-gateway uses `pg`module; ensure`max: 20`is set. Without it, Node can open unbounded connections under load.\n\n# Related\n- ADR-2024-08: Adopt pgbouncer transaction pooling\n- Checklist: CL-2025-09-prod-deploy (verify DB pool settings)\n",
  "language": "en"
}