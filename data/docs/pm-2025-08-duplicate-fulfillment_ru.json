{
  "doc_key": "pm-2025-08-duplicate-fulfillment",
  "title": "Постмортем PM-2025-08: ретраи Stripe webhooks привели к дубликатам отгрузки",
  "doc_type": "postmortem",
  "created_at": "2025-08-10",
  "content": "# Summary\n2025-08-09 краткая нестабильность payment-gateway привела к ретраям Stripe webhooks. Входящие Stripe события были идемпотентны по event_id, но downstream consumer fulfillment-dispatcher оказался не идемпотентен по нашему internal событию orders.paid. В результате часть заказов ушла в отгрузку дважды.\n\nВажно: клиентов не списало дважды, проблема была в логистике и нотификациях.\n\n# Impact\n- 2025-08-09 16:22–16:41 UTC\n- 183 заказа получили duplicate dispatch\n- 61 дубль shipping label\n- 9 упаковок начали готовить дважды, остановили до pickup\n\n# Detection\n- FulfillmentDuplicateDispatchSpike\n- тикеты поддержки: два трек-номера\n- алерт на рост 5xx по /webhooks/stripe и рост stripe_webhook_queue_depth\n\n# Timeline\n- 16:22 payment-gateway рестартится (OOMKilled)\n- 16:24 Stripe ретраит payment_intent.succeeded\n- 16:26 payment-gateway восстановился\n- 16:31 dispatcher отправляет заказы, появляются дубли\n- 16:34 oncall паузит fulfillment-dispatcher\n- 16:37 запускаем скрипт дедупликации\n- 16:41 стабилизация\n\n# Root cause\nДве проблемы:\n1) В payment-gateway был включен флаг LOG_WEBHOOK_PAYLOADS=true (оставили после отладки). Логирование полного payload на INFO привело к росту памяти и OOMKilled.\n2) Внутренняя цепочка transitions не была полностью идемпотентна. Один воркер обработал событие и поставил payment_status=SUCCEEDED, второй воркер повторно прошел путь после transient DB timeout и повторно эмитнул orders.paid, потому что не было уникального ограничения на (order_id, transition).\n\nfulfillment-dispatcher предполагал exactly-once и не проверял уникальность order_id при dispatch.\n\n# Resolution\nСразу:\n- scale fulfillment-dispatcher в 0\n- отмена дублей в warehouse API\n- hotfix checkout-service: эмитить orders.paid только если update реально меняет payment_status\n\nСтабилизация:\n- отключили LOG_WEBHOOK_PAYLOADS и перезадеплоили payment-gateway\n- временно снизили WEBHOOK_MAX_CONCURRENCY\n\n# Corrective actions\n1) Добавить unique constraint:\n`sql\nalter table order_transitions add constraint order_transition_unique unique (order_id, transition_name);\n`\n2) Сделать fulfillment-dispatcher идемпотентным:\n- unique по order_id\n- при дубле логировать и ack без действий\n3) Добавить алерт на OOMKilled payment-gateway\n4) Обновить RB-2026-01 предупреждением про payload logging\n5) Ввести правило в гайдлайнах: все consumers должны предполагать at-least-once\n\n# Что было хорошо\n- Быстро остановили downstream и ограничили радиус\n- Stripe ingestion не создал двойных списаний\n\n# Что было плохо\n- Debug флаги не отделены от прод-настроек\n- Идемпотентность была неполной (внутренние события)\n\n# Дополнительное противоречие\nADR-2024-12 делал ставку на вебхуки. После этого инцидента обсуждался fallback поллинг для VIP заказов. Это НЕ принято как стандартный путь, но появился экспериментальный флаг PAYMENTS_FORCE_POLLING_FALLBACK (включать только по согласованию, иначе можно усугубить 429 на Stripe).\n\n# Ссылки\n- ADR-2024-12\n- RB-2026-01\n- OB-2025-04",
  "language": "ru"
}