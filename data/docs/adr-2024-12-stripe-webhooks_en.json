{
  "doc_key": "adr-2024-12-stripe-webhooks",
  "title": "ADR-2024-12: Stripe Webhooks as Source of Truth for Payment State",
  "doc_type": "adr",
  "created_at": "2024-12-15",
  "content": "# ADR-2024-12: Stripe Webhooks as Source of Truth for Payment State\n\n## Status\nAccepted (2024-12-15)\n\n## Context\nOur payments integration uses Stripe for card payments and refunds. Historically, checkout-service performed **active polling** against Stripe (PaymentIntent retrieval) to determine final state. Polling created operational and product issues:\n\n- Cost and throttling: during peak traffic, we hit Stripe rate limits (`429 Too Many Requests`) and occasionally received `StripeRateLimitError`.\n- Race conditions: polling windows caused state oscillation (order shows pending even though payment succeeded).\n- Complex retries: checkout-service needed retry logic and backoff, increasing p95 latency and error rates.\n- Poor auditability: support had no canonical record of external payment events, only “last polled result”.\n\nWe already operate a legacy Node service (**payment-gateway**) that receives Stripe webhooks, but it was treated as “best effort” and the rest of the platform did not trust its output. As a result we had two competing sources of payment truth.\n\nWe want a single consistent mechanism, with strong idempotency and clear failure modes.\n\n## Decision\nStripe webhooks will be the **authoritative** source for payment state transitions.\n\n- payment-gateway will:\n  1) validate webhook signatures,\n  2) persist raw events to Postgres,\n  3) enqueue internal processing jobs.\n\n- checkout-service will:\n  - update `payments.payment_status` and `orders.status` only based on processed webhook events.\n  - stop polling Stripe in the checkout request path.\n\nPolling remains only as a scheduled reconciliation tool (daily) and for manual support tooling, not for user-facing state changes.\n\n## Technical design\n### Stripe API version pinning\nTo reduce unexpected event shape changes:\n- Pin Stripe API version in payment-gateway to `2023-10-16`.\n- Store the version used in logs for debugging (`stripe_api_version=2023-10-16`).\n\n### Webhook endpoint\n- Route: `POST /webhooks/stripe`\n- Ingress must preserve request body exactly (no JSON reformatting).\n- payment-gateway must use raw body parsing for signature verification:\n  - `express.raw({ type: 'application/json' })` for this route only.\n\n### Signature verification\n- Env var: `STRIPE_WEBHOOK_SECRET`\n- Reject with 400 if signature invalid.\nExpected error signature in logs:\n- `StripeSignatureVerificationError: No signatures found matching the expected signature for payload`\n\n### Persistence (audit log)\nPersist the entire event payload (JSON) in Postgres to support support/debugging and replay.\n\nSchema (approved):\n```sql\ncreate table stripe_events (\n  event_id text primary key,\n  type text not null,\n  created_at timestamptz not null default now(),\n  payload jsonb not null,\n  processed_at timestamptz,\n  process_error text\n);\ncreate index stripe_events_type_created_at_idx on stripe_events (type, created_at desc);\n```\n\n### Processing model\n- payment-gateway enqueues `process_stripe_event(event_id)` into its worker queue.\n- Worker loads event, maps it to internal transitions, writes updates in a single DB transaction.\n- Idempotency is guaranteed by `stripe_events.event_id` primary key and unique constraints on `payments.stripe_event_id`.\n\n### Event ordering\nStripe does not guarantee ordering. The processor must handle:\n- duplicates (same `event_id` replayed)\n- out-of-order (refund-related events arriving before success events in retries)\n\nImplementation rule:\n- always read current payment record before applying transition;\n- transitions are monotonic where possible (e.g., don’t go from `PAID` back to `PENDING`).\n\n### Failure behavior\nIf payment-gateway cannot persist the event:\n- return 500 to Stripe so Stripe retries.\n- do **not** return 2xx without persistence; that creates silent data loss.\n\n## Consequences\n### Positive\n- Reduced Stripe API usage and fewer 429s.\n- Clear audit trail of all incoming external payment events.\n- Cleaner separation: checkout-service orchestrates, payment-gateway integrates with Stripe.\n\n### Negative / risks\n- Operational coupling: webhook ingestion becomes critical path for payment finalization.\n- If webhook signature verification breaks (e.g., body parsing regression), payment state stalls and orders remain pending.\n- Requires runbooks and alerting around queue depth and webhook success rate (see RB-2026-01).\n\n## Alternatives considered\n1. **Continue polling** in checkout-service: rejected due to cost, complexity, and latency.\n2. **Move webhook ingestion directly into checkout-service**: rejected because Stripe keys and webhook secrets are currently owned by payment-gateway, and checkout-service is not yet ready for key custody.\n3. **Publish Stripe events to Kafka**: deferred. Could help decouple processing, but adds infra and operational complexity. Revisit after payment-gateway migration to Python.\n\n## Notes / messy details\n- We must keep `proxy-body-size` high enough for occasional large Stripe events (invoices). Past incidents showed 413s when default ingress limit was 1m.\n- If Redis is down, idempotency still works via Postgres uniqueness, but processing may be slower. Don’t treat Redis as correctness layer here.",
  "language": "en"
}